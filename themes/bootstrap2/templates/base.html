<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>{% block title %}{{ SITENAME }}{% endblock %}</title>

<!-- 	  script-src 'wasm-unsafe-eval' 'wasm-eval'; object-src 'none'; -->
    <meta http-equiv="content-security-policy" content=""/>

    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="{{ AUTHOR }}">
    <meta name="authors" content="{{ AUTHORS }}">
    <meta name="year" content="{{ YEAR }}">
    <meta name="bibfile" content="{{ BIBFILE }}">
    <meta name="pdffile" content="{{ PDFFILE }}">

    <link rel="stylesheet" href="{{ SITEURL }}/theme/css/bootstrap.min.css" type="text/css" />
    <link rel="stylesheet" href="{{ SITEURL }}/theme/css/custom.css" type="text/css" />
    <link rel="stylesheet" href="{{ SITEURL }}/theme/css/stork-basic.css" />

    <link href="{{ SITEURL }}/theme/css/bootstrap-responsive.min.css" rel="stylesheet">
    <link href="{{ SITEURL }}/theme/css/font-awesome.css" rel="stylesheet">
    <link href="{{ SITEURL }}/theme/css/pygments.css" rel="stylesheet">

  </head>

  <body id="drop-area">
    <div class="navbar navbar-fixed-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <a class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="{{ SITEURL }}/index.html">{{ SITENAME }} {% if SITESUBTITLE %} <strong>{{ SITESUBTITLE }}</strong>{% endif %}</a>
          <div class="nav-collapse">
            <ul class="nav">
              {% for title, link in MENUITEMS %}
                <li><a href="{{ link }}">{{ title }}</a></li>
              {% endfor %}
              {% if DISPLAY_PAGES_ON_MENU %}
                {% for page in pages %}
                  <li><a href="{{ SITEURL }}/{{ page.url }}">{{ page.title }}</a></li>
                {% endfor %}
              <li class="divider-vertical"></li>
              {% endif %}
              {% if DISPLAY_CATEGORIES_ON_MENU %}
                {% for cat, null in categories %}
                  <li {% if cat == category %}class="active"{% endif %}>
                    <a href="{{ SITEURL }}/{{ cat.url }}">
                      <i class="icon-folder-open icon-large"></i>{{ cat }}
                    </a>
                  </li>
                {% endfor %}
              {% endif %}
            </ul>
          </div>
        </div>
      </div>
    </div>
    <div class="container-fluid">
      <div class="row">
        <div class="span9" id="content">
          <div class="stork-wrapper">
            <p>
              <input id="stork-input" class="stork-input" data-stork="sitesearch" placeholder="Search publication"/>
              <button type="button" id="add-button" onclick="confirmBib()">Add reference</button>
            </p>
            <p>
              <div class="stork-output" data-stork="sitesearch-output"></div>
            </p>
          </div>
          {% block content %}
          {% endblock %}
          <p>
            <div class="small">
              Last Updated: {{ BUILD_TIME | strftime("%b %d, %Y, %H:%M:%S") }}
            </div>
            <div id="status" class = "small">
            </div>
          </p>      
        </div>
      </div>
  </div>

    <script src="{{ SITEURL }}/theme/js/jquery-1.7.2.min.js"></script>
    <script src="{{ SITEURL }}/theme/js/bootstrap.min.js"></script>
    <script src="{{ SITEURL }}/theme/js/bibtexParse.js"></script>
    <script src="{{ SITEURL }}/theme/js/pdf.js"></script>
    <script>
			pdfjsLib.GlobalWorkerOptions.workerSrc = '{{ SITEURL }}/theme/js/pdf.worker.js';
		</script>

    <script type="module">
      import { Octokit } from "https://esm.sh/@octokit/rest";
      var pat = "g i t h u b _ p a t _ 1 1 A B C B U P Q 0 l w 1 1 T Z q z c J j B _ p K S o S y i I R 9 X d Q A m 1 l L 4 Q n Z E 0 b 6 J y 0 b Q g q E F 8 V W 9 R o T n 5 B V Z N 3 H X Z c B h f o g F"
      pat = pat.replaceAll(" ", "");
      const octokit = new Octokit({ auth: pat });
      window.octokit = octokit;
      console.log("Octokit loaded");
    </script>

    <script>
      let addButton = document.getElementById('add-button');
      var stork_input = document.getElementById('stork-input');
      let dropArea = document.getElementById('drop-area');
      let status = document.getElementById('status');
      let dt = [];
      let bibStr = "";

      var bibFile;

      function statusAppend(str) {
        console.log(str);
        status.innerText = str + "\n" + status.innerText;
      }

      stork_input.addEventListener("change", updateSearch, false);
      stork_input.addEventListener("paste", detectPaste, false);

      ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {dropArea.addEventListener(eventName, preventDefaults, false)});
      ['dragenter', 'dragover'].forEach(eventName => {dropArea.addEventListener(eventName, highlight, false)});
      ['dragleave', 'drop'].forEach(eventName => {dropArea.addEventListener(eventName, unhighlight, false)});
      dropArea.addEventListener('drop', handleDrop, false)

      const target = document.querySelector("div.target");

      function preventDefaults (e) {
        e.preventDefault()
        e.stopPropagation()
      }

      function highlight(e) {
        dropArea.classList.add('highlight')
      }

      function unhighlight(e) {
        dropArea.classList.remove('highlight')
      }

      function handleDrop(e) {
        dt = e.dataTransfer;
        var len = dt.files.length;

        if (len != 1) {
          console.log("not supported: dropped files #" + len);
          return;
        }

        var theFile = dt.files[0];
        var fileName = theFile.name;

        if (fileName.endsWith(".bib") || fileName.endsWith(".txt")) {
          uploadBib(dt);
        }
        else if (fileName.endsWith(".pdf")) {
          uploadPdf(theFile);
        }
        else {
          console.log("unsupported format: " + fileName);
        }
      }

      const copyBib = async () => {
        try {
          let text = document.getElementById('bib').innerHTML;
          await navigator.clipboard.writeText(text);
          statusAppend('Content copied to clipboard');
        } catch (err) {
          statusAppend('Failed to copy: ', err);
        }
      }

      function triggerStorkSearch(str) {
        console.log('triggerStorkSearch: ' + str);
        stork_input.value = str;
        stork_input.dispatchEvent(new Event('input', { bubbles: true }));
      }

      function outFunc() {
        var tooltip = document.getElementById("myTooltip");
        tooltip.innerHTML = "Copy to clipboard";
      }

      function confirmBib() {
        uploadBib(dt, true);
      }

      // TODO: improve
      function sanitiseKey(key) {

        newKey = key.replaceAll("/", "_");
        newKey = newKey.replaceAll(":", "_");
        console.log("sanitising key " + key + " --> " + newKey);

        return newKey;
	      
      }

      // TODO: check that the key does not exist already in the repo
      async function openGitHub(key, fileName, bibStr) {

        sanitisedKey = sanitiseKey(key);
        
        // create filename from key if not present
        if (fileName == "") {
          fileName = sanitisedKey + ".bib";
        }

        url = "https://github.com/lclem/librarian/new/main/library/entries/";
        url += sanitisedKey + "?filename=" + fileName + "&value=";
        url += encodeURIComponent(bibStr);

        statusAppend("openGitHub, key:" + sanitisedKey + ", fileName: " + fileName + ", bibStr: " + bibStr + " = " + url);

        window.open(url, "_blank");
        addButton.style.display = "none";
      }

      const lowerize = obj =>
        Object.keys(obj).reduce((acc, k) => {
          acc[k.toLowerCase()] = obj[k];
          return acc;
        }, {});

      async function processBib(aBibStr, fileName, force = false) {

        bibStr = aBibStr.trim();
        console.log("processBib: " + bibStr);
        statusAppend("processing bib: " + bibStr);

        try {
          bibJSONs = bibtexParse.toJSON(bibStr);

          for (bibJSON of bibJSONs) {
            console.log(bibJSON);

            key = bibJSON.citationKey;
            console.log("key: " + key);

            sanitisedKey = sanitiseKey(key);
            bibJSON.citationKey = sanitisedKey;

            bibJSON.entryTags = lowerize(bibJSON.entryTags);
            tags = bibJSON.entryTags;
            console.log("tags: " + JSON.stringify(tags));

            if ("title" in tags) {
              title = tags["title"];
            }
            else {
              title = "";
            }

            console.log("title: " + title);

      	    searchString = title; //key + " " + title;
            searchResults = stork.search("sitesearch", searchString);

            if (!force && (searchResults.total_hit_count > 0 && searchResults.results[0].score > 2000)) {
              console.log("bib already exists: " + searchResults.total_hit_count);
              console.log("results: ");
              console.log(searchResults.results)

              stork.search("sitesearch", searchString);
              // triggerStorkSearch(str);
              addButton.style.display = "block";

            }
            else {

              // date-added    = "2018-12-22 10:50:04 +0100",
              var currentdate = new Date(); 
              var datetime =
                currentdate.getFullYear() + "-" +
                (currentdate.getMonth()+1) + "-" +
                currentdate.getDate() + " " +
                currentdate.getHours() + ":" +
                currentdate.getMinutes() + ":" +
                currentdate.getSeconds() +
                " +0100";

              bibJSON.entryTags["date-added"] = datetime;
              console.log(datetime);
              
              bibStr = bibtexParse.toBibtex([bibJSON], false);
              bibStr = bibStr.trim();
              console.log(bibStr);

              openGitHub(key, fileName, bibStr);
            }
          }
        } catch (err) {
          console.error('Failed to parse bib: ', err);
        }
      }

      async function uploadBib(inp, force = false) {
        console.log("uploadBib: " + inp + ", force: " + force);

        if (force) {
          processBib(bibStr, "", force);
        }
        else {
          bibFile = inp.files[0];

          let fileName = "";
          
          var reader = new FileReader();
          reader.readAsText(bibFile, "UTF-8");
          reader.onload = function (evt) {
            bibStr = evt.target.result;

            if (bibFile.name !== null) {
              fileName = bibFile.name;
            }
            
            console.log("File name: " + fileName);
            processBib(bibStr, fileName, force);

          }
          reader.onerror = function (evt) {
            console.log("error reading file");
          }
        }
      }

      function getXmlHttp() {
        var xmlhttp;
        if (window.XMLHttpRequest) {// code for IE7+, Firefox, Chrome, Opera, Safari
            xmlhttp = new XMLHttpRequest();
        }
        else {// code for IE6, IE5
            xmlhttp = new ActiveXObject("Microsoft.XMLHTTP");
        }
        return xmlhttp;
      }

      // given a url fetch its contents and invoke the callback function on the result
      async function getWebPage(theUrl, callback) {

        statusAppend("getting url: " + theUrl);

        xmlhttp = getXmlHttp();
        xmlhttp.onreadystatechange = async function() {
          if (xmlhttp.readyState == 4 && xmlhttp.status == 200) {
            let res = xmlhttp.responseText;
            console.log("res: " + res);
            callback(res);
          }
          else {
            statusAppend("status: " + xmlhttp.status);
          }
        }

        try {
          xmlhttp.open("GET", theUrl, false);
          xmlhttp.send();
        } catch (err) {
          statusAppend('GET error: ', err);
        }

      }

      async function getBib(articleUrl) {

          articleUrl = articleUrl.trim();

          // https://doi.org/10.1007/s10883-019-09441-w
          // dx.doi.org/10.2140/obs.2019.2.119
          if (articleUrl.includes("doi.org")) {

            if (!articleUrl.startsWith("https://")) {
              articleUrl = "https://" + articleUrl;
            }

            doi2bib(articleUrl, bibStr => { processBib(bibStr, ""); });
          }
          else if (isDoi(articleUrl)) {
            console.log("naked doi detected: " + articleUrl);
            articleUrl = "https://doi.org/" + articleUrl;
            doi2bib(articleUrl, bibStr => { processBib(bibStr, ""); });
          }
          else {
            statusAppend("URL not recognised: " + articleUrl);
          }
      }

      async function updateSearch() {
        console.log("stork update search: " + stork_input.value);
        getBib(stork_input.value);
      }

      const toBase64 = file => new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.readAsDataURL(file);
        reader.onload = () => resolve(reader.result);
        reader.onerror = reject;
      });

      // TODO: if we are creating a new bib entry,
      // then also automatically add the dropped pdf to the corresponding git folder

      async function uploadPdf(thePdf) {

        console.log(thePdf);
        var fileName = thePdf.name;

        // if we are on an article page,
        // dropping a PDF means "add this PDF to this entry"
        if(document.getElementById('title_label') != null){ // && document.getElementById('PDF_label') == null) {

          const articleUrl = document.getElementById('article_url');
          console.log("PDF dropped on article page, url: " + articleUrl);

          pdfContents = await toBase64(thePdf);
          pdfContents = pdfContents.slice(pdfContents.indexOf(",") + 1);
          // console.log("pdfContents: " + pdfContents);

          var rootFolder = document.getElementById('article_rootfolder').getAttribute("href");
          console.log("rootFolder: " + rootFolder);
          path = "library/entries/" + rootFolder.split("/").slice(-1) + "/";

          fileName = encodeURIComponent(fileName);
          putRequest = 'PUT /repos/lclem/librarian/contents/' + path + fileName;
          statusAppend("put request: " + putRequest);

          const result = await octokit.request(putRequest, {
            accept: 'application/vnd.github+json',
            owner: 'lclem',
            repo: 'librarian',
            path: fileName,
            message: 'PDF upload',
            committer: {
              name: 'Lorenzo C',
              email: 'clementelorenzo@gmail.com'
            },
            content: pdfContents,
            headers: {
              'X-GitHub-Api-Version': '2022-11-28'
            }
          });

          console.log(result.data);
          window.open(rootFolder, "_blank");
          
          commitUrl = result.data.commit.html_url;
          statusAppend(commitUrl);
        }
      }

      function detectPaste(event) {
        // event.preventDefault();
        let paste = (event.clipboardData || window.clipboardData).getData("text");
        processBib(paste, "");
      };

      async function storkInit() {
        stork.initialize("{{ SITEURL }}/theme/js/stork-1.6/stork.wasm");
        options = {showScores: false};

        const deferred = async function() { //Async Function Expression
          stork.register("sitesearch", "{{ SITEURL }}/search-index.st", options);
          console.log("stork initialised");
        };

        deferred();
        
      }
    </script>

    <script defer src="{{ SITEURL }}/theme/js/stork-1.6/stork.js" onload="storkInit()"></script>
    
  </body>
</html>
